<!DOCTYPE html>
<html lang="en">
<head>
	<title>Document</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<style>
		.container {
			top: 0px;
			bottom: 0;
			right: 0px;
			left: 0px;
			position: fixed;
		}
		.fixed_container {
			top: 0;
			bottom: 0;
			right: 0;
			left: 0;
			position: absolute;
			z-index: 1;
			transition: 0.2s ease opacity;
		}
		#drop_zone {
			outline: 5px dashed #bbb;
			outline-offset: -10px;
			text-align: center;
			font: 14vmin/100vmin 'helvetica';
			color: #bbb;
			height: 100vh;
			transition: all 0.2s ease;
			background: rgba(255,255,255,0.7);
		}
		#svg_container svg {
			width: 100%;
		}
		#drop_zone.dragover {
			outline: 8px dashed #333;
			outline-offset: -20px;
			background: #f2f757;
		}
	</style>
</head>
<body>
	<div id="svg_loader">
		<div class="container">
			<div id="svg_container" class="fixed_container"></div>
			<div id="drop_zone" class="fixed_container">Перетяни SVG</div>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" encoding="UTF-8" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="0" height="0" viewBox="0 0 0 0" enable-background="new 0 0 0 0" xml:space="preserve">
			</svg>
		</div>
	</div>
	<script>
//==================================================================================================	
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

		function prepareGroup(svg) {
				var groups = svg.querySelectorAll('#A, #B'); // передаются ID групп
				parseGroup(groups);
		}
		
//..........................................................................................	
		function parseGroup(groups) {
			var diff = {x:0, y:0};
			var current = [];
			groups.forEach(function(group) {
					group.querySelectorAll('path').forEach(function(item) {
							var entryPoint;
							var prevEntryPoint;
							var mI = 0;
							var lI = 0;
							var cI = 1;
							var pathN = 0;
							var enlarge = {
								status : false,
								x : 0,
								y : 0
							};
							var exportString = [];
							var inputString = item.getAttribute('d').replace(/[\n\r]/g, '')
							inputString = inputString.replace(/\s+/g,' ');
							inputString.split(' ').forEach(function(el) {
									 if (el === 'M') entryPoint = 'M';
								else if (el === 'm') entryPoint = 'm';
								else if (el === 'L') entryPoint = 'L';
								else if (el === 'l') entryPoint = 'l';
								else if (el === 'C') entryPoint = 'C';
								else if (el === 'c') entryPoint = 'c';
								else {
									current = el.split(',');
									if (entryPoint === 'm' || entryPoint === 'M') {
										enlarge.status = false;
										cI = 1;
										if (entryPoint === 'm') {
											diff.x = diff.x + parseInt(current[0], 10);
										}
										else {
											diff.x = parseInt(current[0], 10);
											diff.y = parseInt(current[1], 10);										
										}
										if (prevEntryPoint === entryPoint)										
										{
											exportString[pathN] += 'X[ixy]['+ (mI === 0 ? mI = 3 : mI = 0) +']=' + diff.x + '; Y[ixy]['+ mI +']=' + diff.y + '; ';
											if (mI === 3) {
												exportString[pathN] += 'v[ixy]=true; ixy++;';
												pathN++;
												exportString[pathN] = '';
											}
										}
										else {
											exportString[pathN] = 'X[ixy][0]=' + diff.x + ';Y[ixy][0]=' + diff.y + '; ';
										}
									}
									else if (entryPoint === 'c' || entryPoint === 'C') {
										enlarge.status = true;
										enlarge.x = cI === 1 ? diff.x : enlarge.x;
										enlarge.y = cI === 1 ? diff.y : enlarge.y;
										
										if (entryPoint === 'c') {
											diff.x = !enlarge.status ? diff.x + parseInt(current[0], 10) : enlarge.x + parseInt(current[0], 10);
											diff.y = !enlarge.status ? diff.y + parseInt(current[1], 10) : enlarge.y + parseInt(current[1], 10);
										}
										else {
											diff.x = parseInt(current[0], 10);
											diff.y = parseInt(current[1], 10);
										}											
											
										if (cI % 3 !== 0) {
											exportString[pathN] += 'X[ixy]['+ cI +']=' + diff.x + ';Y[ixy]['+ cI +']=' + diff.y + '; ';
											cI++;
										}
										else if(cI % 3 === 0) {
											exportString[pathN] += 'X[ixy]['+ cI +']=' + diff.x + '; Y[ixy]['+ cI +']=' + diff.y + ';';
											exportString[pathN] += 'v[ixy]=false; ixy++;';
											pathN++;
											exportString[pathN] = '';
											enlarge.status = false;
											cI = 1;
										}
									}

									else if (entryPoint === 'l' || entryPoint === 'L') {
										enlarge.status = false;
										cI = 1;
										if (entryPoint === 'l') {
											diff.x = diff.x + parseInt(current[0], 10);
										}
										else {
											diff.x = parseInt(current[0], 10);
											diff.y = parseInt(current[1], 10);										
										}
										exportString[pathN] += 'X[ixy]['+ (lI === 0 ? lI = 4 : lI = 0) +']=' + current[0] + '; Y[ixy]['+ lI +']=' + current[1] + '; ';
										if (lI === 4) {
											exportString[pathN] += 'v[ixy]=true; ixy++;';
											pathN++;
											exportString[pathN] = '';
										}
									}
									prevEntryPoint = entryPoint;
								}

							});

							//console.log('Путь: ' + item.getAttribute('id') + '\n' + '------------------------------------');
							/*exportString.forEach(function(string){
								console.log(string);
							})*/
							console.log(exportString.join('\n'));
							//console.log('\n');
					});
			});
		}


//=======================================================================================================
		function renderSvg(code) {
				var svgContainer = document.getElementById('svg_container');
				svgContainer.innerHTML = code;
				dropZone.parentNode.removeChild(dropZone);
				prepareGroup(svgContainer.querySelector('svg'));
		}
		
		function handleFileSelect(evt) {
				dropZone.classList.remove('dragover');
				evt.stopPropagation();
				evt.preventDefault();
				var files = evt.dataTransfer.files;
				var file = files[0];
				var start = 0;
				var stop = file.size - 1;
				var reader = new FileReader();
				reader.onloadend = function(evt) {
						if (evt.target.readyState == FileReader.DONE) { // DONE == 2
								document.getElementById('svg_loader').value = evt.target.result;
								renderSvg(evt.target.result);
						}
				};
				var blob = file.slice(start, stop + 1);
				reader.readAsText(blob);
		}

		function handleDragOver(evt) {
				evt.stopPropagation();
				evt.preventDefault();
				evt.dataTransfer.dropEffect = 'copy';
				dropZone.classList.add('dragover');
		}

		function handleDragLeave(evt) {
				dropZone.classList.remove('dragover');
		}

		var dropZone = document.getElementById('drop_zone');
		dropZone.addEventListener('dragover', handleDragOver, false);
		dropZone.addEventListener('dragleave', handleDragLeave, false);
		dropZone.addEventListener('drop', handleFileSelect, false);
	</script>
</body>
</html>


